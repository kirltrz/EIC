// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.1
// LVGL version: 9.1.0
// Project name: EIC

#include "ui.h"
#include "Arduino.h"
#include "ota.h"
#include "Wire.h"
#include "motion.h"
#include "arm.h"
#include "sensor.h"
#include "ZDT_MOTOR_EMM_V5.h"
#include "LED.h"
#include "mainSequence.h"
#include "displayInterface.h"
#include "PAW3395.h"
#include "usr_spi.h"

void toNextPos(lv_event_t *e)
{
	motor->enControl(MOTOR_BROADCAST, true);
	static int current_pos_index = 0;
	moveTo(pos[current_pos_index]);
	//DEBUG_LOG("移动到位置x: %lf, y: %lf, yaw: %f", pos[current_pos_index].x, pos[current_pos_index].y, pos[current_pos_index].yaw);
	current_pos_index++;
	if (current_pos_index >= sizeof(pos) / sizeof(pos[0]))
	{
		current_pos_index = 0;
	}
	/*
	global_position_t currentPosition;
	getGlobalPosition(&currentPosition);
	POS pos = {currentPosition.x, currentPosition.y + 500.0, currentPosition.rawYaw + 90.0f};
	moveTo(pos);*/
}

// lockCurrentPos改为自动跑全程
void lockCurrentPos(lv_event_t *e)
{
	motor->enControl(MOTOR_BROADCAST, true);
	for (int i = 0; i < sizeof(que) / sizeof(que[0]); i++)
	{
		moveTo(que[i]);
		waitNear();
	}
}

void enableMotor(lv_event_t *e)
{
	// 获取开关状态
	lv_obj_t *sw = (lv_obj_t *)lv_event_get_target(e);
	bool is_checked = lv_obj_has_state(sw, LV_STATE_CHECKED);

	if (is_checked)
	{
		// 开关打开，使能电机
		motor->enControl(MOTOR_BROADCAST, is_checked);
		stopArm(2000);
		// LED(1);
		DEBUG_LOG("电机已使能");
	}
	else
	{
		// 开关关闭，失能电机
		motor->enControl(MOTOR_BROADCAST, is_checked);
		stopArm(0);
		// LED(0);
		DEBUG_LOG("电机已失能");
	}
}

void servoSetOringin(lv_event_t *e)
{
	setOriginPoint();
}

void stopServo(lv_event_t *e)
{
	stopArm(false);
}

void startOTA(lv_event_t *e)
{
	initOTA();
}

void updateArmInfo(lv_event_t *e)
{
	char buf[10][30];
	float angle[5];
	float xyz[3];

	/*获取舵机角度*/
	angle[0] = servo0.queryAngle();
	angle[1] = servo1.queryAngle();
	angle[2] = servo2.queryAngle();
	angle[3] = servo3.queryAngle();
	angle[4] = servo4.queryAngle();

	/*将角度转换为字符串*/
	sprintf(buf[0], "%.2f", angle[0]);
	sprintf(buf[1], "%.2f", angle[1]);
	sprintf(buf[2], "%.2f", angle[2]);
	sprintf(buf[3], "%.2f", angle[3]);
	sprintf(buf[4], "%.2f", angle[4]);

	/*根据角度计算xyz坐标*/
	armCalculate_forward(angle[0], angle[1], angle[2], xyz);

	/*将xyz坐标转换为字符串*/
	sprintf(buf[5], "%.2f", xyz[0]);
	sprintf(buf[6], "%.2f", xyz[1]);
	sprintf(buf[7], "%.2f", xyz[2]);

	/*更新ui中舵机角度*/
	lv_label_set_text(ui_servo0angle, buf[0]);
	lv_label_set_text(ui_servo1angle, buf[1]);
	lv_label_set_text(ui_servo2angle, buf[2]);
	lv_label_set_text(ui_servo3angle, buf[3]);
	lv_label_set_text(ui_servo4angle, buf[4]);

	/*更新ui中xyz坐标*/
	lv_label_set_text(ui_armX, buf[5]);
	lv_label_set_text(ui_armY, buf[6]);
	lv_label_set_text(ui_armZ, buf[7]);

	/*更新xyz坐标滑动条*/
	lv_slider_set_value(ui_armXSlider, xyz[0], LV_ANIM_OFF);
	lv_slider_set_value(ui_armYSlider, xyz[1], LV_ANIM_OFF);
	lv_slider_set_value(ui_armZSlider, xyz[2], LV_ANIM_OFF);
}

void applyPID(lv_event_t *e)
{
	// 从UI控件中获取PID参数
	float pos_kp = lv_spinbox_get_value(ui_moving_pos_Kp) / 1000.0f; // 位置环比例系数
	float pos_ki = lv_spinbox_get_value(ui_moving_pos_Ki) / 1000.0f; // 位置环积分系数
	float pos_kd = lv_spinbox_get_value(ui_moving_pos_Kd) / 1000.0f; // 位置环微分系数

	float yaw_kp = lv_spinbox_get_value(ui_moving_yaw_Kp) / 1000.0f; // 偏航角比例系数
	float yaw_ki = lv_spinbox_get_value(ui_moving_yaw_Ki) / 1000.0f; // 偏航角积分系数
	float yaw_kd = lv_spinbox_get_value(ui_moving_yaw_Kd) / 1000.0f; // 偏航角微分系数

	// 从UI控件中获取速度参数
	float linear_speed = lv_spinbox_get_value(ui_moving_spd_linear) / 10.0f;	 // 线速度，单位mm/s
	float angular_speed = lv_spinbox_get_value(ui_moving_spd_angular) / 1000.0f; // 角速度，单位度/s

	// 检查开关状态，决定更新哪组PID参数
	bool is_holding_mode = lv_obj_has_state(ui_Switch1, LV_STATE_CHECKED);

	if (is_holding_mode)
	{
		// 更新保持模式的PID参数
		HOLD_POS_KP = pos_kp;
		HOLD_POS_KI = pos_ki;
		HOLD_POS_KD = pos_kd;
		HOLD_YAW_KP = yaw_kp;
		HOLD_YAW_KI = yaw_ki;
		HOLD_YAW_KD = yaw_kd;

		// 更新保持模式的速度参数
		HOLD_MAX_LINEAR_SPEED = linear_speed;
		HOLD_MAX_ANGULAR_SPEED = angular_speed;

		DEBUG_LOG("已应用保持模式PID参数: POS(%.2f,%.2f,%.2f) YAW(%.2f,%.2f,%.2f) SPD(%.1f,%.1f)",
				  HOLD_POS_KP, HOLD_POS_KI, HOLD_POS_KD,
				  HOLD_YAW_KP, HOLD_YAW_KI, HOLD_YAW_KD,
				  HOLD_MAX_LINEAR_SPEED, HOLD_MAX_ANGULAR_SPEED);
	}
	else
	{
		// 更新移动模式的PID参数
		POS_KP = pos_kp;
		POS_KI = pos_ki;
		POS_KD = pos_kd;
		YAW_KP = yaw_kp;
		YAW_KI = yaw_ki;
		YAW_KD = yaw_kd;

		// 更新移动模式的速度参数
		MAX_LINEAR_SPEED = linear_speed;
		MAX_ANGULAR_SPEED = angular_speed;

		DEBUG_LOG("已应用移动模式PID参数: POS(%.2f,%.2f,%.2f) YAW(%.2f,%.2f,%.2f) SPD(%.1f,%.1f)",
				  POS_KP, POS_KI, POS_KD,
				  YAW_KP, YAW_KI, YAW_KD,
				  MAX_LINEAR_SPEED, MAX_ANGULAR_SPEED);
	}
	resetPIDparam(); // 重置PID积分项及last_error
}

void switchPIDtarget(lv_event_t *e)
{
	// 获取开关状态（是否切换到保持模式）
	bool is_holding_mode = lv_obj_has_state(ui_Switch1, LV_STATE_CHECKED);

	// 根据模式切换，更新UI显示的参数值
	if (is_holding_mode)
	{
		// 切换到保持模式，显示保持模式的参数
		lv_spinbox_set_value(ui_moving_pos_Kp, (int32_t)(HOLD_POS_KP * 1000));
		lv_spinbox_set_value(ui_moving_pos_Ki, (int32_t)(HOLD_POS_KI * 1000));
		lv_spinbox_set_value(ui_moving_pos_Kd, (int32_t)(HOLD_POS_KD * 1000));

		lv_spinbox_set_value(ui_moving_yaw_Kp, (int32_t)(HOLD_YAW_KP * 1000));
		lv_spinbox_set_value(ui_moving_yaw_Ki, (int32_t)(HOLD_YAW_KI * 1000));
		lv_spinbox_set_value(ui_moving_yaw_Kd, (int32_t)(HOLD_YAW_KD * 1000));

		lv_spinbox_set_value(ui_moving_spd_linear, (int32_t)(HOLD_MAX_LINEAR_SPEED * 10));
		lv_spinbox_set_value(ui_moving_spd_angular, (int32_t)(HOLD_MAX_ANGULAR_SPEED * 1000));

		DEBUG_LOG("已切换到保持模式参数");
	}
	else
	{
		// 切换到移动模式，显示移动模式的参数
		lv_spinbox_set_value(ui_moving_pos_Kp, (int32_t)(POS_KP * 1000));
		lv_spinbox_set_value(ui_moving_pos_Ki, (int32_t)(POS_KI * 1000));
		lv_spinbox_set_value(ui_moving_pos_Kd, (int32_t)(POS_KD * 1000));

		lv_spinbox_set_value(ui_moving_yaw_Kp, (int32_t)(YAW_KP * 1000));
		lv_spinbox_set_value(ui_moving_yaw_Ki, (int32_t)(YAW_KI * 1000));
		lv_spinbox_set_value(ui_moving_yaw_Kd, (int32_t)(YAW_KD * 1000));

		lv_spinbox_set_value(ui_moving_spd_linear, (int32_t)(MAX_LINEAR_SPEED * 10));
		lv_spinbox_set_value(ui_moving_spd_angular, (int32_t)(MAX_ANGULAR_SPEED * 1000));

		DEBUG_LOG("已切换到移动模式参数");
	}
}

void setArmPos(lv_event_t *e)
{
	float xyz[3];
	uint16_t interval, acc, dec;
	xyz[0] = lv_slider_get_value(ui_armXSlider);
	xyz[1] = lv_slider_get_value(ui_armYSlider);
	xyz[2] = lv_slider_get_value(ui_armZSlider);

	interval = lv_spinbox_get_value(ui_armIntervalSpinbox);
	acc = lv_spinbox_get_value(ui_armACC_DECSpinbox);
	dec = acc;

	armControl_xyz(xyz[0], xyz[1], xyz[2], interval, acc, dec);
}

void uiSetClaw(lv_event_t * e)
{
    bool state = lv_obj_has_state(ui_uiSetClawSwitch, LV_STATE_CHECKED);
    servo4.setAngle(state ? ARM_GRIPPER_CLOSE_ANGLE : ARM_GRIPPER_OPEN_ANGLE,100);
}

void armTestFunc(lv_event_t *e)
{
	int taskcode[3]={1,2,3};
	arm_putToMaterial(taskcode);
}

void armTestFunc2(lv_event_t * e)
{
	int taskcode[3]={1,2,3};
	arm_catchFromGround(taskcode, 1);
}

void armTestFunc3(lv_event_t * e)
{
	int taskcode[3]={1,2,3};
	arm_putToGround(taskcode);
}

void ui_resetSensor(lv_event_t * e)
{
	resetSensor();
}

void testFunc(lv_event_t * e)
{
	// 获取按钮对象
	lv_obj_t *btn = (lv_obj_t *)lv_event_get_target(e);
	lv_obj_t *label = lv_obj_get_child(btn, 0);
	
	if (label == NULL) {
		DEBUG_LOG("无法获取按钮标签");
		return;
	}
	arm_groundDetect(0);
	/*
	int taskcode[3]={1,2,3};
	setGlobalPosition(pos[1].x, pos[1].y);
	motor->enControl(MOTOR_BROADCAST, true);
	caliTurntable();
	arm_catchFromTurntable(taskcode);
	*/
	//armControl_xyz(240.0f,0.0f,240.0f,1000,100,100,false);
	/*
	DEBUG_LOG("开始固件辅助抬起截止校准...");
	
	// 提示用户开始移动
	lv_label_set_text(label, "请移动鼠标");
	lv_refr_now(NULL);
	
	// 初始化校准参数
	uint8_t varA, varB, varC;
	motion_burst_data_t burst_data;
	uint32_t squal_accumulator = 0;
	uint32_t rawdata_sum_accumulator = 0;
	uint32_t squal2_accumulator = 0;
	uint16_t sample_count = 0;
	uint16_t progress_update_interval = MIN_MOTION_SAMPLES / 10; // 每10%更新一次进度
	
	// 设置默认值
	varA = 0x25;
	varB = 0x0C; 
	varC = 0x30;
	
	// 步骤1：收集至少3000个样本
	while (sample_count < MIN_MOTION_SAMPLES) {
		Motion_Burst_Extended(&burst_data);
		
		// 只在有运动时累加数据
		if (burst_data.motion & 0x80) { // 检查运动标志位
			squal_accumulator += burst_data.squal;
			rawdata_sum_accumulator += burst_data.rawdata_sum;
			squal2_accumulator += burst_data.squal2;
			sample_count++;
			
			// 每收集一定数量样本更新进度显示
			if (sample_count % progress_update_interval == 0) {
				uint8_t progress = (sample_count * 100) / MIN_MOTION_SAMPLES;
				char progress_msg[30];
				sprintf(progress_msg, "采样中...%d%%", progress);
				lv_label_set_text(label, progress_msg);
				lv_refr_now(NULL);
			}
		}
		
		delay_ms(1); // 小延时避免过快采样
	}
	
	// 显示分析中
	lv_label_set_text(label, "分析数据...");
	lv_refr_now(NULL);
	
	// 计算平均值
	uint16_t squal_avg = squal_accumulator / sample_count;
	uint16_t rawdata_sum_avg = rawdata_sum_accumulator / sample_count;
	uint16_t squal2_avg = squal2_accumulator / sample_count;
	
	// 步骤2：确定SQUAL阈值
	uint8_t squal_th = (rawdata_sum_avg < 48) ? 23 : 30;
	
	// 步骤3：计算SQUAL比率
	uint16_t squal_ratio = 0;
	if (squal_avg > 0) {
		squal_ratio = (squal2_avg * 100) / squal_avg;
	}
	
	// 步骤4：检查是否检测到独特表面
	bool unique_surface_detected = false;
	if ((squal_ratio < squal_th) && (rawdata_sum_avg < 68)) {
		// 检测到独特表面，更新参数
		varA = 0x25;
		varB = 0x0C;
		varC = 0x2D;
		unique_surface_detected = true;
		
		// 启用校准设置
		Enable_Lift_Cutoff_Calibration(varA, varB, varC);
		
		// 显示成功信息
		char success_msg[50];
		sprintf(success_msg, "独特表面 A:%02X B:%02X C:%02X", varA, varB, varC);
		lv_label_set_text(label, success_msg);
		
		DEBUG_LOG("固件辅助校准成功! 检测到独特表面");
		DEBUG_LOG("SQUAL比率: %d, 阈值: %d, RawSum平均: %d", squal_ratio, squal_th, rawdata_sum_avg);
		DEBUG_LOG("校准参数 - VarA: 0x%02X, VarB: 0x%02X, VarC: 0x%02X", varA, varB, varC);
		
	} else {
		// 未检测到独特表面，使用默认值
		char default_msg[50];
		sprintf(default_msg, "通用设置 A:%02X B:%02X C:%02X", varA, varB, varC);
		lv_label_set_text(label, default_msg);
		
		DEBUG_LOG("固件辅助校准完成! 未检测到独特表面，使用通用设置");
		DEBUG_LOG("SQUAL比率: %d, 阈值: %d, RawSum平均: %d", squal_ratio, squal_th, rawdata_sum_avg);
		DEBUG_LOG("默认参数 - VarA: 0x%02X, VarB: 0x%02X, VarC: 0x%02X", varA, varB, varC);
	}
	
	// 5秒后恢复按钮原始文本
	delay_ms(5000);
	lv_label_set_text(label, "测试");
	*/
}

void testLongPressedFunc(lv_event_t * e)
{
	// 获取按钮对象
	lv_obj_t *btn = (lv_obj_t *)lv_event_get_target(e);
	lv_obj_t *label = lv_obj_get_child(btn, 0);
	
	if (label == NULL) {
		DEBUG_LOG("无法获取按钮标签");
		return;
	}
	
	/*
	DEBUG_LOG("开始手动抬起截止校准...");
	
	// 提示用户校准开始
	lv_label_set_text(label, "初始化...");
	lv_refr_now(NULL);
	
	// 执行校准前的准备工作
	uint8_t var_mode;
	uint8_t calibration_status;
	uint8_t timeout_counter = 0;
	const uint8_t MAX_TIMEOUT = 200;
	
	// 开始校准程序
	cs_low();
	delay_125_ns(PAW3395_TIMINGS_NCS_SCLK);
	
	// 按照PAW3395手册执行校准步骤
	write_register(0x7F, 0x00);
	delay_us(PAW3395_TIMINGS_SWW);
	
	var_mode = read_register(0x40);
	delay_us(PAW3395_TIMINGS_SRWSRR);
	
	write_register(0x40, 0x80);
	delay_us(PAW3395_TIMINGS_SWW);
	
	write_register(0x7F, 0x05);
	delay_us(PAW3395_TIMINGS_SWW);
	
	write_register(0x43, 0xE7);
	delay_us(PAW3395_TIMINGS_SWW);
	
	write_register(0x7F, 0x04);
	delay_us(PAW3395_TIMINGS_SWW);
	
	write_register(0x40, 0xC0);
	delay_us(PAW3395_TIMINGS_SWW);
	
	write_register(0x41, 0x10);
	delay_us(PAW3395_TIMINGS_SWW);
	
	// 写入寄存器0x44-0x4B
	for (uint8_t reg = 0x44; reg <= 0x4B; reg++) {
		write_register(reg, 0x0C);
		delay_us(PAW3395_TIMINGS_SWW);
	}
	
	// 启动校准
	write_register(0x40, 0xC1);
	delay_us(PAW3395_TIMINGS_SWW);
	
	cs_high();
	delay_125_ns(PAW3395_TIMINGS_BEXIT);
	
	// 提示用户移动鼠标，分阶段显示倒计时
	for (int countdown = 5; countdown > 0; countdown--) {
		char msg[50];
		sprintf(msg, "移动鼠标%ds", countdown);
		lv_label_set_text(label, msg);
		lv_refr_now(NULL);
		delay_ms(1000);
	}
	
	// 停止校准过程
	cs_low();
	delay_125_ns(PAW3395_TIMINGS_NCS_SCLK);
	write_register(0x40, 0x40);
	delay_us(PAW3395_TIMINGS_SWW);
	
	// 提示检查结果
	lv_label_set_text(label, "检查结果...");
	lv_refr_now(NULL);
	
	// 检查校准状态
	bool calibration_success = false;
	do {
		calibration_status = read_register(CALIBRATION_STATUS_REG);
		delay_us(PAW3395_TIMINGS_SRWSRR);
		
		if ((calibration_status & 0x0F) == CALIBRATION_SUCCESS) {
			calibration_success = true;
			break;
		}
		
		delay_ms(50);
		timeout_counter++;
	} while (timeout_counter < MAX_TIMEOUT);
	
	// 处理校准结果
	if (calibration_success) {
		// 校准成功，读取校准结果
		uint8_t varA = read_register(CALIBRATION_RESULT_REG);
		delay_us(PAW3395_TIMINGS_SRWSRR);
		
		write_register(0x7F, 0x0C);
		delay_us(PAW3395_TIMINGS_SWW);
		
		uint8_t varB = 0x0C;
		uint8_t varC = 0x30;
		
		write_register(LIFT_CUTOFF_CONFIG, UNIVERSAL_1MM_SETTING);
		delay_us(PAW3395_TIMINGS_SWW);
		
		write_register(0x7F, 0x05);
		delay_us(PAW3395_TIMINGS_SWW);
		write_register(0x43, 0xE4);
		delay_us(PAW3395_TIMINGS_SWW);
		
		write_register(0x7F, 0x00);
		delay_us(PAW3395_TIMINGS_SWW);
		write_register(0x40, var_mode);
		
		cs_high();
		delay_125_ns(PAW3395_TIMINGS_BEXIT);
		
		// 启用校准设置
		Enable_Lift_Cutoff_Calibration(varA, varB, varC);
		
		// 显示校准成功及参数
		char success_msg[60];
		sprintf(success_msg, "成功A:%02X B:%02X C:%02X", varA, varB, varC);
		lv_label_set_text(label, success_msg);
		
		DEBUG_LOG("校准成功! VarA: 0x%02X, VarB: 0x%02X, VarC: 0x%02X", varA, varB, varC);
		
	} else {
		// 校准失败，恢复默认设置
		write_register(LIFT_CUTOFF_CONFIG, UNIVERSAL_1MM_SETTING);
		delay_us(PAW3395_TIMINGS_SWW);
		
		write_register(0x7F, 0x05);
		delay_us(PAW3395_TIMINGS_SWW);
		write_register(0x43, 0xE4);
		delay_us(PAW3395_TIMINGS_SWW);
		
		write_register(0x7F, 0x00);
		delay_us(PAW3395_TIMINGS_SWW);
		write_register(0x40, var_mode);
		
		cs_high();
		delay_125_ns(PAW3395_TIMINGS_BEXIT);
		
		// 显示校准失败
		lv_label_set_text(label, "校准失败");
		DEBUG_LOG("校准失败，已恢复默认设置");
	}
	
	// 5秒后恢复按钮原始文本
	delay_ms(5000);
	lv_label_set_text(label, "测试");
	*/
}
